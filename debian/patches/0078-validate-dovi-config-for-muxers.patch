Index: FFmpeg/libavformat/movenc.c
===================================================================
--- FFmpeg.orig/libavformat/movenc.c
+++ FFmpeg/libavformat/movenc.c
@@ -2538,8 +2538,79 @@ static int mov_write_video_tag(AVFormatC
             mov_write_st3d_tag(s, pb, (AVStereo3D*)stereo_3d->data);
         if (spherical_mapping)
             mov_write_sv3d_tag(mov->fc, pb, (AVSphericalMapping*)spherical_mapping->data);
-        if (dovi)
-            mov_write_dvcc_dvvc_tag(s, pb, (AVDOVIDecoderConfigurationRecord *)dovi->data);
+        if (dovi) {
+            AVDOVIDecoderConfigurationRecord* dovi_config = (AVDOVIDecoderConfigurationRecord *) dovi->data;
+            int is_dovi_config_valid = 1;
+            switch (dovi_config->dv_level) {
+                case 4:
+                case 5:
+                case 7:
+                case 8:
+                case 20:
+                    if (track->par->codec_id != AV_CODEC_ID_HEVC) {
+                        is_dovi_config_valid = 0;
+                    }
+                    break;
+                case 9:
+                    if (track->par->codec_id != AV_CODEC_ID_H264) {
+                        is_dovi_config_valid = 0;
+                    }
+                    break;
+                case 10:
+                    if (track->par->codec_id != AV_CODEC_ID_AV1) {
+                        is_dovi_config_valid = 0;
+                    }
+                    break;
+                default:
+                    is_dovi_config_valid = 0;
+                    break;
+            }
+
+            switch (dovi_config->dv_bl_signal_compatibility_id) {
+                case 0:
+                    if (track->par->color_range != AVCOL_RANGE_JPEG ||
+                        track->par->format != AV_PIX_FMT_YUV420P10 ||
+                        !(track->tag == MKTAG('d', 'v', 'h', '1') ||
+                          track->tag == MKTAG('d', 'v', 'h', 'e') ||
+                          track->tag == MKTAG('d', 'a', 'v', '1'))) {
+                        is_dovi_config_valid = 0;
+                    }
+                    break;
+                case 1:
+                case 6:
+                    if (track->par->color_trc != AVCOL_TRC_SMPTE2084 ||
+                        track->par->color_primaries != AVCOL_PRI_BT2020 ||
+                        track->par->color_space != AVCOL_SPC_BT2020_NCL ||
+                        track->par->color_range != AVCOL_RANGE_MPEG ||
+                        track->par->format != AV_PIX_FMT_YUV420P10) {
+                        is_dovi_config_valid = 0;
+                    }
+                    break;
+                case 2:
+                    // Don't check range or color info for SDR base layer as a lot of them will set to unspecified
+                    // And a lot of players assumes unspecified as BT709 in tv range
+                    if (track->par->format != AV_PIX_FMT_YUV420P) {
+                        is_dovi_config_valid = 0;
+                    }
+                    break;
+                case 4:
+                    if (track->par->color_trc != AVCOL_TRC_ARIB_STD_B67 ||
+                        track->par->color_primaries != AVCOL_PRI_BT2020 ||
+                        track->par->color_space != AVCOL_SPC_BT2020_NCL ||
+                        track->par->color_range != AVCOL_RANGE_MPEG ||
+                        track->par->format != AV_PIX_FMT_YUV420P10) {
+                        is_dovi_config_valid = 0;
+                    }
+                    break;
+                default:
+                    // others are reserved value, don't check
+                    break;
+            }
+
+            if (is_dovi_config_valid) {
+                mov_write_dvcc_dvvc_tag(s, pb, dovi_config);
+            }
+        }
     }
 
     if (track->par->sample_aspect_ratio.den && track->par->sample_aspect_ratio.num) {
Index: FFmpeg/libavformat/matroskaenc.c
===================================================================
--- FFmpeg.orig/libavformat/matroskaenc.c
+++ FFmpeg/libavformat/matroskaenc.c
@@ -1719,28 +1719,96 @@ static void mkv_write_blockadditionmappi
 
     dovi = (const AVDOVIDecoderConfigurationRecord *)sd->data;
     if (dovi->dv_profile <= 10) {
-        ebml_master mapping;
-        uint8_t buf[ISOM_DVCC_DVVC_SIZE];
-        uint32_t type;
-
-        uint64_t expected_size = (2 + 1 + (sizeof(DVCC_DVVC_BLOCK_TYPE_NAME) - 1))
-                                + (2 + 1 + 4) + (2 + 1 + ISOM_DVCC_DVVC_SIZE);
-
-        if (dovi->dv_profile > 7) {
-            type = MATROSKA_BLOCK_ADD_ID_TYPE_DVVC;
-        } else {
-            type = MATROSKA_BLOCK_ADD_ID_TYPE_DVCC;
+        int is_dovi_config_valid = 1;
+        switch (dovi->dv_level) {
+            case 4:
+            case 5:
+            case 7:
+            case 8:
+            case 20:
+                if (par->codec_id != AV_CODEC_ID_HEVC) {
+                    is_dovi_config_valid = 0;
+                }
+                break;
+            case 9:
+                if (par->codec_id != AV_CODEC_ID_H264) {
+                    is_dovi_config_valid = 0;
+                }
+                break;
+            case 10:
+                if (par->codec_id != AV_CODEC_ID_AV1) {
+                    is_dovi_config_valid = 0;
+                }
+                break;
+            default:
+                is_dovi_config_valid = 0;
+                break;
         }
 
-        ff_isom_put_dvcc_dvvc(s, buf, dovi);
+        switch (dovi->dv_bl_signal_compatibility_id) {
+            case 0:
+                if (par->color_range != AVCOL_RANGE_JPEG ||
+                    par->format != AV_PIX_FMT_YUV420P10 ||
+                    !(par->codec_tag == MKTAG('d', 'v', 'h', '1') ||
+                      par->codec_tag == MKTAG('d', 'v', 'h', 'e') ||
+                      par->codec_tag == MKTAG('d', 'a', 'v', '1'))) {
+                    is_dovi_config_valid = 0;
+                }
+                break;
+            case 1:
+            case 6:
+                if (par->color_trc != AVCOL_TRC_SMPTE2084 ||
+                    par->color_primaries != AVCOL_PRI_BT2020 ||
+                    par->color_space != AVCOL_SPC_BT2020_NCL ||
+                    par->color_range != AVCOL_RANGE_MPEG ||
+                    par->format != AV_PIX_FMT_YUV420P10) {
+                    is_dovi_config_valid = 0;
+                }
+                break;
+            case 2:
+                // Don't check range or color info for SDR base layer as a lot of them will set to unspecified
+                // And a lot of players assumes unspecified as BT709 in tv range
+                if (par->format != AV_PIX_FMT_YUV420P) {
+                    is_dovi_config_valid = 0;
+                }
+                break;
+            case 4:
+                if (par->color_trc != AVCOL_TRC_ARIB_STD_B67 ||
+                    par->color_primaries != AVCOL_PRI_BT2020 ||
+                    par->color_space != AVCOL_SPC_BT2020_NCL ||
+                    par->color_range != AVCOL_RANGE_MPEG ||
+                    par->format != AV_PIX_FMT_YUV420P10) {
+                    is_dovi_config_valid = 0;
+                }
+                break;
+            default:
+                // others are reserved value, don't check
+                break;
+        }
+        if (is_dovi_config_valid) {
+            ebml_master mapping;
+            uint8_t buf[ISOM_DVCC_DVVC_SIZE];
+            uint32_t type;
+
+            uint64_t expected_size = (2 + 1 + (sizeof(DVCC_DVVC_BLOCK_TYPE_NAME) - 1))
+                                     + (2 + 1 + 4) + (2 + 1 + ISOM_DVCC_DVVC_SIZE);
+
+            if (dovi->dv_profile > 7) {
+                type = MATROSKA_BLOCK_ADD_ID_TYPE_DVVC;
+            } else {
+                type = MATROSKA_BLOCK_ADD_ID_TYPE_DVCC;
+            }
 
-        mapping = start_ebml_master(pb, MATROSKA_ID_TRACKBLKADDMAPPING, expected_size);
+            ff_isom_put_dvcc_dvvc(s, buf, dovi);
 
-        put_ebml_string(pb, MATROSKA_ID_BLKADDIDNAME, DVCC_DVVC_BLOCK_TYPE_NAME);
-        put_ebml_uint(pb, MATROSKA_ID_BLKADDIDTYPE, type);
-        put_ebml_binary(pb, MATROSKA_ID_BLKADDIDEXTRADATA, buf, sizeof(buf));
+            mapping = start_ebml_master(pb, MATROSKA_ID_TRACKBLKADDMAPPING, expected_size);
 
-        end_ebml_master(pb, mapping);
+            put_ebml_string(pb, MATROSKA_ID_BLKADDIDNAME, DVCC_DVVC_BLOCK_TYPE_NAME);
+            put_ebml_uint(pb, MATROSKA_ID_BLKADDIDTYPE, type);
+            put_ebml_binary(pb, MATROSKA_ID_BLKADDIDEXTRADATA, buf, sizeof(buf));
+
+            end_ebml_master(pb, mapping);
+        }
     }
 #endif
 }
