Index: FFmpeg/libavcodec/bsf/h265_metadata.c
===================================================================
--- FFmpeg.orig/libavcodec/bsf/h265_metadata.c
+++ FFmpeg/libavcodec/bsf/h265_metadata.c
@@ -27,6 +27,7 @@
 #include "h2645data.h"
 #include "hevc.h"
 #include "h265_profile_level.h"
+#include "itut35.h"
 
 enum {
     LEVEL_UNSET = -2,
@@ -62,6 +63,8 @@ typedef struct H265MetadataContext {
     int level;
     int level_guess;
     int level_warned;
+    int remove_dovi;
+    int remove_hdr10plus;
 } H265MetadataContext;
 
 
@@ -385,6 +388,37 @@ static int h265_metadata_update_fragment
             if (err < 0)
                 return err;
         }
+        if (ctx->remove_dovi) {
+            if (au->units[i].type == HEVC_NAL_UNSPEC62) { // Dolby Vision RPU
+                ff_cbs_delete_unit(au, i);
+                av_log(bsf, AV_LOG_DEBUG, "Removing Dolby Vision RPU\n");
+            }
+            if (au->units[i].type == HEVC_NAL_UNSPEC63) { // Dolby Vision EL
+                ff_cbs_delete_unit(au, i);
+                av_log(bsf, AV_LOG_DEBUG, "Removing Dolby Vision EL\n");
+            }
+        }
+        if (ctx->remove_hdr10plus) {
+            // This implementation is not strictly correct as it does not decode the entire NAL.
+            // There could be multiple SEIs packed within a single NAL, and some of them may not be HDR10+ metadata.
+            // The current implementation simply removes the entire NAL without further inspection.
+            if (au->units[i].type == HEVC_NAL_SEI_PREFIX && au->units[i].data_size > 8 * sizeof(uint8_t)) {
+                uint8_t *nal_sei = au->units[i].data;
+                // This Matches ITU-T T.35 SMPTE ST 2094-40
+                if (nal_sei[0] == 0x4E && nal_sei[1] == 0x01 && nal_sei[2] == 0x04) {
+                    if (nal_sei[4] == ITU_T_T35_COUNTRY_CODE_US && nal_sei[6] == ITU_T_T35_PROVIDER_CODE_SMTPE) {
+                        // identifier for HDR10+
+                        const uint8_t smpte2094_40_provider_oriented_code = 0x01;
+                        const uint8_t smpte2094_40_application_identifier = 0x04;
+                        if (nal_sei[8] == smpte2094_40_provider_oriented_code && nal_sei[9] == smpte2094_40_application_identifier) {
+                            av_log(bsf, AV_LOG_DEBUG, "Found HDR10+ metadata, removing NAL\n");
+                            ff_cbs_delete_unit(au, i);
+                        }
+                    }
+
+                }
+            }
+        }
     }
 
     return 0;
@@ -399,6 +433,11 @@ static const CBSBSFType h265_metadata_ty
 
 static int h265_metadata_init(AVBSFContext *bsf)
 {
+    if (((H265MetadataContext *)bsf->priv_data)->remove_dovi) {
+        av_packet_side_data_remove(bsf->par_out->coded_side_data,
+                                   &bsf->par_out->nb_coded_side_data,
+                                   AV_PKT_DATA_DOVI_CONF);
+    }
     return ff_cbs_bsf_generic_init(bsf, &h265_metadata_type);
 }
 
@@ -478,6 +517,13 @@ static const AVOption h265_metadata_opti
     { LEVEL("8.5", 255) },
 #undef LEVEL
 
+    { "remove_dovi", "Remove Dolby Vision BL and RPU",
+      OFFSET(remove_dovi), AV_OPT_TYPE_BOOL,
+      { .i64 = 0 }, 0, 1, FLAGS },
+    { "remove_hdr10plus", "Remove NALs including HDR10+ metadata",
+      OFFSET(remove_hdr10plus), AV_OPT_TYPE_BOOL,
+      { .i64 = 0 }, 0, 1, FLAGS },
+
     { NULL }
 };
 
